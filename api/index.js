const express = require('express');
const { MongoClient } = require('mongodb');
const cors = require('cors');
const path = require('path');
const session = require('express-session');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const app = express();

// Vari√°veis de ambiente para Vercel
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://webpulse:silva225566@elohimformulario.vcympy9.mongodb.net/?retryWrites=true&w=majority&appName=elohimformulario';
const ADMIN_USERNAME = process.env.ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'elohim2024';
const SESSION_SECRET = process.env.SESSION_SECRET || 'elohim-secret-key-2024';

// Middleware
app.use(cors()); // Simplificado para debug
app.use(express.json());

// Servir arquivos est√°ticos SEMPRE (n√£o s√≥ em desenvolvimento)
app.use(express.static(path.join(__dirname, '../public')));

// Configura√ß√£o de sess√£o para Vercel
app.use(session({
    secret: SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: process.env.NODE_ENV === 'production', // true apenas em produ√ß√£o
        maxAge: 24 * 60 * 60 * 1000,
        sameSite: process.env.NODE_ENV === 'production' ? 'none' : 'lax',
        httpOnly: true,
        domain: process.env.NODE_ENV === 'production' ? '.vercel.app' : undefined
    },
    name: 'elohim-session' // Nome personalizado para evitar conflitos
}));

// Store para tokens de sess√£o simples (em mem√≥ria para esta demonstra√ß√£o)
let activeTokens = new Set();

// Store para credenciais atualizadas (inicializado com padr√µes)
let currentCredentials = {
    username: ADMIN_USERNAME,
    password: ADMIN_PASSWORD
};

// Fun√ß√£o para carregar credenciais do banco de dados
async function loadCredentialsFromDatabase() {
    try {
        const database = await connectToDatabase();
        const settings = database.collection('settings');

        const credentialDoc = await settings.findOne({ type: 'admin_credentials' });

        if (credentialDoc) {
            currentCredentials.username = credentialDoc.username;
            currentCredentials.password = credentialDoc.password;
            console.log('‚úÖ Credenciais carregadas do banco de dados:', credentialDoc.username);
            return true;
        } else {
            console.log('‚ÑπÔ∏è Nenhuma credencial encontrada no banco, usando padr√£o');
            return false;
        }
    } catch (error) {
        console.error('‚ùå Erro ao carregar credenciais do banco:', error.message);
        return false;
    }
}

// Fun√ß√£o para salvar credenciais no banco de dados
async function saveCredentialsToDatabase(username, password) {
    try {
        if (!client) {
            console.log('MongoDB n√£o conectado, n√£o foi poss√≠vel salvar credenciais');
            return false;
        }

        const database = await connectToDatabase();
        const settings = database.collection('settings');

        await settings.updateOne(
            { type: 'admin_credentials' },
            {
                $set: {
                    username: username,
                    password: password,
                    updatedAt: new Date()
                }
            },
            { upsert: true }
        );

        console.log('‚úÖ Credenciais salvas no banco de dados');
        return true;
    } catch (error) {
        console.error('‚ùå Erro ao salvar credenciais no banco:', error);
        return false;
    }
}

// Fun√ß√£o para gerar token simples
function generateSimpleToken() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

// Middleware de autentica√ß√£o alternativo baseado em token
function requireAuthToken(req, res, next) {
    const token = req.headers['x-auth-token'];

    if (token && activeTokens.has(token)) {
        next();
    } else if (req.session && req.session.authenticated) {
        // Fallback para sess√£o tradicional (localhost)
        next();
    } else {
        res.status(401).json({ error: 'Authentication required' });
    }
}

// Middleware de autentica√ß√£o original (mantido para compatibilidade)
function requireAuth(req, res, next) {
    if (req.session.authenticated) {
        next();
    } else {
        res.status(401).json({ error: 'Authentication required' });
    }
}

// Conex√£o com MongoDB
let client;
let db;

async function connectToDatabase() {
    try {
        if (!client) {
            console.log('üîÑ Conectando ao MongoDB...');
            client = new MongoClient(MONGODB_URI);
            await client.connect();
            db = client.db('elohim_fitness');
            console.log('‚úÖ Conectado ao MongoDB Atlas');
        }
        return db;
    } catch (error) {
        console.error('‚ùå Erro ao conectar ao MongoDB:', error.message);
        client = null;
        throw error;
    }
}

// Rotas da API

// Teste simples
app.get('/api/test', (req, res) => {
    res.json({
        message: 'Servidor funcionando!',
        credentials: {
            username: currentCredentials.username,
            hasPassword: !!currentCredentials.password
        }
    });
});

// Endpoint tempor√°rio para inicializar credenciais (vers√£o simplificada)
app.post('/api/init-credentials', (req, res) => {
    try {
        const { username, password } = req.body;

        if (!username || !password) {
            return res.status(400).json({
                success: false,
                message: 'Username e password s√£o obrigat√≥rios'
            });
        }

        // Salvar diretamente na mem√≥ria (sem MongoDB por enquanto)
        currentCredentials.username = username;
        currentCredentials.password = password;

        console.log(`‚úÖ Credenciais inicializadas: ${username}`);

        res.json({
            success: true,
            message: 'Credenciais inicializadas com sucesso (em mem√≥ria)'
        });
    } catch (error) {
        console.error('Erro ao inicializar credenciais:', error);
        res.status(500).json({
            success: false,
            message: 'Erro interno do servidor'
        });
    }
});
app.get('/api/auth/status', (req, res) => {
    try {
        const token = req.headers['x-auth-token'];
        const sessionAuth = !!(req.session && req.session.authenticated);
        const tokenAuth = token && activeTokens.has(token);

        console.log('Verificando status de autentica√ß√£o:', {
            sessionID: req.sessionID,
            sessionAuth,
            tokenAuth,
            token: token ? 'presente' : 'ausente',
            activeTokensCount: activeTokens.size,
            sessionUsername: req.session ? req.session.username : 'none'
        });

        res.json({
            authenticated: sessionAuth || tokenAuth,
            sessionID: req.sessionID,
            method: tokenAuth ? 'token' : sessionAuth ? 'session' : 'none',
            username: req.session ? req.session.username : null
        });
    } catch (error) {
        console.error('Erro ao verificar status de autentica√ß√£o:', error);
        res.status(500).json({
            authenticated: false,
            error: 'Erro interno do servidor'
        });
    }
});// Rota para enviar feedback
app.post('/api/feedback', async (req, res) => {
    try {
        const database = await connectToDatabase();
        const feedbacks = database.collection('feedbacks');

        const feedbackData = {
            ...req.body,
            timestamp: new Date(),
            ip: req.ip || req.connection.remoteAddress
        };

        const result = await feedbacks.insertOne(feedbackData);
        console.log('‚úÖ Novo feedback salvo - Academia Elohim Fitness:', result.insertedId);

        res.json({
            success: true,
            message: 'Feedback enviado com sucesso para Academia Elohim Fitness!'
        });
    } catch (error) {
        console.error('‚ùå Erro ao salvar feedback da Academia Elohim Fitness:', error);
        res.status(500).json({
            error: 'Erro interno do servidor da Academia Elohim Fitness'
        });
    }
});

// Rota para login
app.post('/api/login', async (req, res) => {
    try {
        const { username, password } = req.body;

        console.log('Tentativa de login:', { username, hasPassword: !!password });
        console.log('Environment:', process.env.NODE_ENV);
        console.log('Credenciais atuais:', {
            username: currentCredentials.username,
            hasPassword: !!currentCredentials.password
        });

        // Tentar carregar credenciais do banco se ainda n√£o foram carregadas
        if (currentCredentials.username === ADMIN_USERNAME && currentCredentials.password === ADMIN_PASSWORD) {
            console.log('üîÑ Recarregando credenciais do banco...');
            await loadCredentialsFromDatabase();
        }

        if (username === currentCredentials.username && password === currentCredentials.password) {
            // Autentica√ß√£o tradicional para localhost
            req.session.authenticated = true;
            req.session.username = username;

            // Gerar token para Vercel
            const token = generateSimpleToken();
            activeTokens.add(token);

            // Limpar tokens antigos ap√≥s 24 horas
            setTimeout(() => {
                activeTokens.delete(token);
            }, 24 * 60 * 60 * 1000);

            console.log('‚úÖ Login bem-sucedido para usu√°rio:', username);

            res.json({
                success: true,
                message: 'Login realizado com sucesso!',
                token: token,
                username: username
            });
        } else {
            console.log('‚ùå Credenciais inv√°lidas para usu√°rio:', username);
            console.log('Esperado:', { username: currentCredentials.username });
            console.log('Recebido:', { username, password: password ? '[HIDDEN]' : '[EMPTY]' });

            res.status(401).json({
                success: false,
                error: 'Credenciais inv√°lidas'
            });
        }
    } catch (error) {
        console.error('‚ùå Erro no login:', error);
        res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

// Rota para logout
app.post('/api/logout', (req, res) => {
    const token = req.headers['x-auth-token'];

    if (token) {
        activeTokens.delete(token);
    }

    req.session.destroy();
    res.json({ success: true, message: 'Logout realizado com sucesso!' });
});

// Rota de debug para verificar credenciais (remover em produ√ß√£o)
app.get('/api/debug/credentials', async (req, res) => {
    try {
        // Recarregar credenciais do banco
        await loadCredentialsFromDatabase();

        res.json({
            environment: process.env.NODE_ENV,
            hasMongoUri: !!process.env.MONGODB_URI,
            defaultUsername: ADMIN_USERNAME,
            currentUsername: currentCredentials.username,
            hasCurrentPassword: !!currentCredentials.password,
            usingDefaultCredentials: currentCredentials.username === ADMIN_USERNAME && currentCredentials.password === ADMIN_PASSWORD
        });
    } catch (error) {
        res.status(500).json({
            error: error.message
        });
    }
});

// Rota para obter todos os feedbacks (protegida)
app.get('/api/feedbacks', requireAuthToken, async (req, res) => {
    try {
        const database = await connectToDatabase();
        const feedbacks = database.collection('feedbacks');
        const allFeedbacks = await feedbacks.find({}).sort({ timestamp: -1 }).toArray();
        res.json(allFeedbacks);
    } catch (error) {
        console.error('‚ùå Erro ao buscar feedbacks:', error);
        res.status(500).json({ error: 'Erro interno do servidor' });
    }
});

// Rota para deletar feedback (protegida)
app.delete('/api/feedback/:id', requireAuthToken, async (req, res) => {
    try {
        const { ObjectId } = require('mongodb');
        const database = await connectToDatabase();
        const feedbacks = database.collection('feedbacks');

        const result = await feedbacks.deleteOne({ _id: new ObjectId(req.params.id) });

        if (result.deletedCount === 1) {
            res.json({ success: true, message: 'Feedback exclu√≠do com sucesso!' });
        } else {
            res.status(404).json({ error: 'Feedback n√£o encontrado' });
        }
    } catch (error) {
        console.error('‚ùå Erro ao excluir feedback:', error);
        res.status(500).json({ error: 'Erro interno do servidor' });
    }
});

// Rota para atualizar credenciais - PROTEGIDA
app.post('/api/update-credentials', requireAuthToken, async (req, res) => {
    try {
        const { newUsername, currentPassword, newPassword } = req.body;

        // Verificar se todos os campos foram enviados
        if (!newUsername || !currentPassword || !newPassword) {
            return res.status(400).json({
                success: false,
                message: 'Todos os campos s√£o obrigat√≥rios'
            });
        }

        // Verificar senha atual
        if (currentPassword !== currentCredentials.password) {
            return res.status(401).json({
                success: false,
                message: 'Senha atual incorreta'
            });
        }

        // Validar nova senha (m√≠nimo 6 caracteres)
        if (newPassword.length < 6) {
            return res.status(400).json({
                success: false,
                message: 'A nova senha deve ter pelo menos 6 caracteres'
            });
        }

        // Atualizar credenciais
        currentCredentials.username = newUsername;
        currentCredentials.password = newPassword;

        // Salvar no banco de dados
        const saved = await saveCredentialsToDatabase(newUsername, newPassword);

        console.log(`‚úÖ Credenciais atualizadas - Usu√°rio: ${newUsername} - Salvo no DB: ${saved}`);

        res.json({
            success: true,
            message: saved ? 'Credenciais atualizadas com sucesso' : 'Credenciais atualizadas (n√£o foi poss√≠vel salvar no banco)'
        });

    } catch (error) {
        console.error('Erro ao atualizar credenciais:', error);
        res.status(500).json({
            success: false,
            message: 'Erro interno do servidor'
        });
    }
});

// Rota para verificar autentica√ß√£o
app.get('/api/auth/check', (req, res) => {
    res.json({ authenticated: !!req.session.authenticated });
});

// Rotas para servir p√°ginas HTML SEMPRE
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, '../public/index.html'));
});

app.get('/login', (req, res) => {
    res.sendFile(path.join(__dirname, '../public/login.html'));
});

app.get('/painel', (req, res) => {
    res.sendFile(path.join(__dirname, '../public/painel.html'));
});

// Exportar app para Vercel
module.exports = app;

// Inicializar credenciais do banco de dados para Vercel
if (require.main !== module) {
    // Executar imediatamente no ambiente Vercel
    console.log('üîÑ Inicializando credenciais para Vercel...');
    loadCredentialsFromDatabase()
        .then(() => {
            console.log('‚úÖ Credenciais carregadas do banco no Vercel');
        })
        .catch(error => {
            console.error('‚ùå Erro ao carregar credenciais no Vercel:', error);
            console.log('‚ö†Ô∏è Usando credenciais padr√£o');
        });
}

// Para execu√ß√£o local
if (require.main === module) {
    const port = process.env.PORT || 3000;
    app.listen(port, async () => {
        console.log(`üöÄ Servidor Academia Elohim Fitness rodando na porta ${port}`);
        console.log(`üìù Formul√°rio: http://localhost:${port}`);
        console.log(`üîê Login Admin: http://localhost:${port}/login`);
        console.log(`üìä Painel Admin: http://localhost:${port}/painel`);

        // Carregar credenciais do banco de dados na inicializa√ß√£o
        console.log('üîÑ Carregando credenciais do banco de dados...');
        const loaded = await loadCredentialsFromDatabase();
        if (loaded) {
            console.log('‚úÖ Credenciais do banco carregadas com sucesso');
        } else {
            console.log('‚ö†Ô∏è Usando credenciais padr√£o do .env');
        }
    });
}
